#!/usr/bin/env python3

import socket
import json
import os
import errno
import getopt
import sys

# region Constants
header = "##\n" \
         "# This file has been generated by the HostUpdater script.\n" \
         "# Don't edit this file by hand,\n" \
         "# rather edit the config file of the script.\n" \
         "# \n" \
         "# Copyright EyeDevelop 2017.\n" \
         "##\n"

local = "127.0.0.1\t\t\t{} {} {}\n".format(
    "localhost",
    "localhost.localdomain",
    socket.gethostname()
)

local6 = "::1\t\t\t\t\t{} {} {}\n".format(
    "localhost",
    "localhost.localdomain",
    socket.gethostname()
)

broadcasthost = "255.255.255.255\t\tbroadcasthost\n"

entries = []
conf = None

# endregion


def generate_config(config):
    with open(os.path.join(os.getcwd(), config), 'w') as conf:
        default = "{\n" \
                  "    \"include_header\":\"yes\",\n" \
                  "    \"include_local_entries\":\"yes\",\n" \
                  "    \"include_broadcasthost\":\"yes\",\n" \
                  "    \n" \
                  "    \"addresses\":{\n" \
                  "        \n" \
                  "    }\n" \
                  "}\n"
        conf.write(default)


def main(save_as, to_stdout):
    global conf

    if conf["include_header"].lower() == "yes":
        entries.append(header)

    if conf["include_local_entries"].lower() == "yes":
        entries.append(local)
        entries.append(local6)

    if conf["include_broadcasthost"].lower() == "yes":
        entries.append(broadcasthost)

    for key in conf["addresses"]:
        if "dynamic:" in key:
            addr = socket.gethostbyname(key.split(":")[1].lower())
        else:
            addr = key

        hosts = [host.lower() for host in conf["addresses"][key]]

        entries.append("{}\t\t{}".format(addr, " ".join(hosts)))

    if not to_stdout:
        with open(os.path.join(os.getcwd(), save_as), 'w') as hosts:
            hosts.write("\n".join(entries))
            hosts.write("\n")
    else:
        print("\n".join(entries))


def validate_ip(str_ip):
    if str_ip.count(".") != 3:
        return False

    if not all([True if 0 <= x <= 255 else False for x in map(int, str_ip.split("."))]):
        return False

    return True


def validate_config(config):
    global conf

    with open(os.path.join(os.getcwd(), config), 'r') as fp_conf:
        try:
            conf = json.load(fp_conf)
        except ValueError:
            print("ERROR: Config file is not valid JSON!")
            exit(1)

    if not conf["include_header"] or not (conf["include_header"].lower() == "yes" or conf["include_header"].lower() == "no"):
        print("CONF_ERR: Invalid value for 'include_header'!")
        exit(1)

    if not conf["include_local_entries"] or not (conf["include_local_entries"].lower() == "yes" or conf["include_local_entries"].lower() == "no"):
        print("CONF_ERR: Invalid value for 'include_local_entries'!")
        exit(1)

    if not conf["include_broadcasthost"] or not (conf["include_broadcasthost"].lower() == "yes" or conf["include_broadcasthost"].lower() == "no"):
        print("CONF_ERR: Invalid value for 'include_broadcasthost'!")
        exit(1)

    for key in conf["addresses"]:
        if "dynamic:" in key:
            if not key.split(":")[1]:
                print("CONF_ERR: One or more dynamic hosts have no reference!")
                exit(1)

            try:
                socket.gethostbyname(key.split(":")[1])
            except OSError:
                print("DNS_ERR: Name {} could not be resolved!".format(key.split(":")[1]))
                exit(1)

        else:
            if not validate_ip(key):
                print("CONF_ERR: {} is not a valid ip addresses!".format(key))
                exit(1)


if __name__ == "__main__":
    # Command line parameters
    # c: Custom config file
    # o: Custom output file
    # g: ONLY generate clean config

    config = ".".join(sys.argv[0].split(".")[:-1]) + ".config.json"
    outfile = "hosts.new"
    genconfig = False
    to_stdout = False

    opts, _ = getopt.getopt(sys.argv[1:], "c:o:gh", ["config=", "outfile=", "regen", "to-stdout", "help"])
    for i in opts:
        if i[0] == "-h" or i[0] == "--help":
            print("HostUpdater Script Commandline Options:\n"
                  "\n"
                  "-c <file> | --config=<file>, specify a custom config file.\n"
                  "-o <file> | --outfile=<file>, specify a custom output file.\n"
                  "-g        | --regen, regenerate config file.\n"
                  "          | --to-stdout, output to STDOUT instead of a file.\n"
                  "-h        | --help, shows this help.\n")
            exit(0)

        elif i[0] == "-c" or i[0] == "--config":
            config = i[1]

        elif i[0] == "-o" or i[0] == "--outfile":
            outfile = i[1]

        elif i[0] == "-g" or i[0] == "--regen":
            genconfig = True

        elif i[0] == "--to-stdout":
            to_stdout = True

    if genconfig:
        generate_config(config)
        print("INFO: New config file generated!")
        exit(0)

    try:
        if not os.path.exists(os.path.join(os.getcwd(), config)):
            generate_config(config)
            print("INFO: Config file didn't exist, written new config.\n"
                  "      Please edit the config to your liking.")
            exit(0)

        validate_config(config)

        main(outfile, to_stdout)
    except OSError as osex:
        # region File Errors
        if osex.errno == errno.EACCES:
            print("ERROR: No read/write permission!")
            exit(1)
        elif osex.errno == errno.EROFS:
            print("ERROR: Read only filesystem!")
            exit(1)
        # endregion

        # region Network Errors
        elif osex.errno == errno.ECONNRESET:
            print("DNS_ERR: Connection reset!")
            exit(1)
        elif osex.errno == errno.ECONNREFUSED:
            print("DNS_ERR: Connection refused!")
            exit(1)
        elif osex.errno == errno.ENETDOWN:
            print("DNS_ERR: Network is down!")
            exit(1)
        elif osex.errno == errno.ENETUNREACH:
            print("DNS_ERR: Network unreachable!")
            exit(1)

        # endregion

    if not to_stdout:
        print("INFO: New hosts successfully file saved as {}!".format(outfile))
